<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Person Detection — Dashboard</title>
  <style>
    body{font-family:Arial, Helvetica, sans-serif;background:#f4f6f8;margin:0;padding:24px}
    .container{max-width:1100px;margin:0 auto}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;gap:12px}
    h1{font-size:20px;margin:0}
    .header-right{display:flex;align-items:center;gap:10px}
    #videoWrap{background:#000;border-radius:8px;overflow:hidden;height:540px;display:flex;justify-content:center;align-items:center;position:relative;transition:all .25s ease}
    #stream{width:100%;height:100%;object-fit:cover;display:block}
    .controls{display:flex;gap:12px;align-items:center;margin-top:10px}
    .countBox{background:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
    .btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer;background:#1f6feb;color:#fff}
    .btn.logout{background:#e53e3e}
    .btn.alt{background:#6b7280}
    /* modal */
    .modal{position:fixed;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:9999}
    .modal.show{display:flex}
    .modal-card{background:#fff;padding:20px;border-radius:8px;max-width:420px;text-align:center}
    .modal-card h2{margin:0 0 8px}

    /* Mini mode */
    .mini {
      position: fixed !important;
      width: 320px !important;
      height: 180px !important;
      bottom: 18px;
      right: 18px;
      z-index: 9998;
      border-radius: 8px;
      box-shadow: 0 12px 40px rgba(2,6,23,0.35);
      transform: translateZ(0);
    }

    /* Full fallback overlay mode (non-Fullscreen API) */
    .overlay-full {
      position: fixed !important;
      left: 0 !important;
      top: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
      z-index: 9997;
      border-radius: 0 !important;
    }

    /* Small responsive adjustments */
    @media (max-width:980px){
      #videoWrap{height:360px}
      .mini{width:220px;height:140px}
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Person Detection Dashboard</h1>

      <div class="header-right">
        <div style="font-size:13px;color:#333">Signed in as: <strong>{{ session.get('user_email') }}</strong></div>

        <!-- Full / Min controls -->
        <button id="minBtn" class="btn alt" title="Mini screen">Min</button>
        <button id="fullBtn" class="btn" title="Full screen">Full</button>

        <a href="{{ url_for('snapshot') }}" target="_blank"><button class="btn alt" title="Snapshot">Snapshot</button></a>
        <a href="{{ url_for('logout') }}"><button class="btn logout" title="Logout">Logout</button></a>
      </div>
    </header>

    <section id="main">
      <div id="videoWrap" aria-live="polite">
        <img id="stream" src="{{ url_for('video_feed') }}" alt="Live stream">
      </div>

      <div class="controls">
        <div class="countBox">Persons detected: <strong id="count">0</strong></div>
      </div>
    </section>
  </div>

  <!-- Modal alert -->
  <div id="alertModal" class="modal" role="dialog" aria-hidden="true">
    <div class="modal-card">
      <h2>⚠️ Alert</h2>
      <p>More than 5 persons detected!</p>
      <div style="margin-top:12px">
        <button id="dismissBtn" class="btn">Dismiss</button>
      </div>
    </div>
  </div>

  <!-- Optional sound (place a small beep file at static/snd/alert.mp3) -->
  <audio id="alertSound" preload="auto">
    <source src="{{ url_for('static', filename='snd/alert.mp3') }}" type="audio/mpeg">
  </audio>

  <script>
    // Poll backend count endpoint and show popup when alert==true
    let alertShown = false;
    const cooldownMs = 20000; // 20s before showing alert again
    let lastAlertTs = 0;

    function updateCountAndAlert() {
      fetch('/count').then(r => {
        if (!r.ok) throw new Error('count fetch failed');
        return r.json();
      }).then(data => {
        // update count UI
        const cntEl = document.getElementById('count');
        if(cntEl) cntEl.innerText = data.persons;

        // handle alert
        if (data.alert) {
          const now = Date.now();
          if (!alertShown && (now - lastAlertTs) > cooldownMs) {
            // show modal
            alertShown = true;
            lastAlertTs = now;
            document.getElementById('alertModal').classList.add('show');
            // play sound if available
            const s = document.getElementById('alertSound');
            if (s) {
              s.currentTime = 0;
              s.play().catch(()=>{/* ignore play errors */});
            }
          }
        }
      }).catch(err => {
        // console.log('count poll error', err);
      });
    }

    // dismiss modal
    document.getElementById('dismissBtn').addEventListener('click', () => {
      document.getElementById('alertModal').classList.remove('show');
      alertShown = false;
      // do not allow immediate re-alert; cooldown handled by lastAlertTs
    });

    // start polling
    setInterval(updateCountAndAlert, 1000);
    updateCountAndAlert();

    // ---------------- Full / Mini screen logic ----------------
    const videoWrap = document.getElementById('videoWrap');
    const fullBtn = document.getElementById('fullBtn');
    const minBtn = document.getElementById('minBtn');
    let isMini = false;
    let usingFullscreenAPI = false;
    let overlayFallback = false;

    function enterMini() {
      // if already fullscreen via API, exit it first
      if (document.fullscreenElement) {
        document.exitFullscreen().catch(()=>{});
      }
      videoWrap.classList.remove('overlay-full');
      videoWrap.classList.add('mini');
      isMini = true;
    }

    function exitMini() {
      videoWrap.classList.remove('mini');
      isMini = false;
    }

    function enterFullFallback() {
      // fallback overlay full (if Fullscreen API not available or failed)
      videoWrap.classList.add('overlay-full');
      overlayFallback = true;
    }

    function exitFullFallback() {
      videoWrap.classList.remove('overlay-full');
      overlayFallback = false;
    }

    // Full button handler — prefers Fullscreen API
    fullBtn.addEventListener('click', async () => {
      try {
        // If currently mini, revert first
        if (isMini) exitMini();

        if (document.fullscreenEnabled) {
          // toggle fullscreen
          if (!document.fullscreenElement) {
            await videoWrap.requestFullscreen();
            usingFullscreenAPI = true;
          } else {
            await document.exitFullscreen();
            usingFullscreenAPI = false;
          }
        } else {
          // fallback overlay
          if (!overlayFallback) enterFullFallback();
          else exitFullFallback();
        }
      } catch (e) {
        // fallback overlay if fullscreen fails
        if (!overlayFallback) enterFullFallback();
        else exitFullFallback();
      }
    });

    // Min button toggles mini mode
    minBtn.addEventListener('click', () => {
      if (isMini) {
        exitMini();
      } else {
        // if in fullscreen API, exit it
        if (document.fullscreenElement) {
          document.exitFullscreen().catch(()=>{});
          usingFullscreenAPI = false;
        }
        // also remove overlay fallback if active
        if (overlayFallback) exitFullFallback();
        enterMini();
      }
    });

    // Clean up on Esc when fullscreen or overlay
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (document.fullscreenElement) {
          document.exitFullscreen().catch(()=>{});
        }
        if (overlayFallback) exitFullFallback();
        if (isMini) exitMini();
      }
    });

    // If user exits fullscreen via browser controls, make sure state updated
    document.addEventListener('fullscreenchange', () => {
      if (!document.fullscreenElement) {
        usingFullscreenAPI = false;
      } else {
        usingFullscreenAPI = true;
      }
    });

    // If the user drags/resizes or orientation changes, ensure mini fits viewport
    window.addEventListener('resize', () => {
      if (isMini) {
        // adjust small-screen mini size
        if (window.innerWidth < 400) {
          videoWrap.style.width = '220px';
          videoWrap.style.height = '140px';
        } else {
          videoWrap.style.width = '';
          videoWrap.style.height = '';
        }
      } else {
        videoWrap.style.width = '';
        videoWrap.style.height = '';
      }
    });
  </script>
</body>
</html>
